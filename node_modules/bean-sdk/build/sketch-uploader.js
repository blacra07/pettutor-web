'use strict';

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var fsm = require('./util/fsm');
var logger = require('./util/logs').logger;
var util = require('./util/util');
var commandIds = require('./command-definitions').commandIds;
var buffer = require('buffer');
var timers = require('timers');

var BLOCK_SIZE = 64;

// Sketch Uploader states
var STATE_INACTIVE = 'STATE_INACTIVE';
var STATE_AWAIT_READY = 'STATE_AWAIT_READY';
var STATE_BLOCK_TRANSFER = 'STATE_BLOCK_TRANSFER';
var STATE_COMPLETED = 'STATE_COMPLETED';

// Bean States
var BEAN_STATE_READY = 2;
var BEAN_STATE_PROGRAMMING = 3;
var BEAN_STATE_VERIFY = 4;
var BEAN_STATE_COMPLETE = 5;
var BEAN_STATE_ERROR = 6;

// Bean Sub-state
var BEAN_SUBSTATE_INIT = 0;
var BEAN_SUBSTATE_WRITE_ADDRESS = 1;
var BEAN_SUBSTATE_WRITE_ADDRESS_ACK = 2;
var BEAN_SUBSTATE_WRITE_CHUNK = 3;
var BEAN_SUBSTATE_WRITE_CHUNK_ACK = 4;
var BEAN_SUBSTATE_READ_ADDRESS = 5;
var BEAN_SUBSTATE_READ_ADDRESS_ACK = 6;
var BEAN_SUBSTATE_READ_CHUNK = 7;
var BEAN_SUBSTATE_READ_CHUNK_ACK = 8;
var BEAN_SUBSTATE_VERIFY = 9;
var BEAN_SUBSTATE_DONE = 10;
var BEAN_SUBSTATE_DONE_ACK = 11;
var BEAN_SUBSTATE_START = 12;
var BEAN_SUBSTATE_START_ACK = 13;
var BEAN_SUBSTATE_HELLO = 14;
var BEAN_SUBSTATE_HELLO_ACK = 15;
var BEAN_SUBSTATE_START_RSTAGAIN = 16;
var BEAN_SUBSTATE_DONE_RESET = 17;
var BEAN_SUBSTATE_PROG_MODE = 18;
var BEAN_SUBSTATE_PROG_MODE_ACK = 19;
var BEAN_SUBSTATE_DEVICE_SIG = 20;
var BEAN_SUBSTATE_DEVICE_SIG_ACK = 21;
var BEAN_SUBSTATE_WRITE_CHUNK_TWO = 22;
var BEAN_SUBSTATE_ERROR = 23;

var SketchUploader = function () {
  function SketchUploader() {
    _classCallCheck(this, SketchUploader);

    this._process = null;
  }

  _createClass(SketchUploader, [{
    key: 'beginUpload',
    value: function beginUpload(device, sketchBuf, sketchName, promptUser, callback) {
      this._process = new UploadProcess(device, sketchBuf, sketchName, promptUser, callback);
      this._process.start();
    }
  }]);

  return SketchUploader;
}();

var UploadProcess = function (_fsm$Context) {
  _inherits(UploadProcess, _fsm$Context);

  function UploadProcess(device, sketchBuf, sketchName, promptUser, callback) {
    _classCallCheck(this, UploadProcess);

    var _this = _possibleConstructorReturn(this, (UploadProcess.__proto__ || Object.getPrototypeOf(UploadProcess)).call(this));

    _this._device = device;
    _this._sketchBuf = sketchBuf;
    _this._sketchName = sketchName;
    _this._promptUser = promptUser;
    _this._callback = callback;

    _this.initStates({
      STATE_INACTIVE: StateInactive,
      STATE_AWAIT_READY: StateAwaitReady,
      STATE_BLOCK_TRANSFER: StateBlockTransfer,
      STATE_COMPLETED: StateCompleted
    });

    _this.setState(STATE_INACTIVE);
    return _this;
  }

  _createClass(UploadProcess, [{
    key: '_statusCommandReceived',
    value: function _statusCommandReceived(status) {
      logger.debug('New Bean State: ' + status.state);
      if (status.state === BEAN_STATE_ERROR) {
        var out = 'Bean sketch upload error!\n';
        out += '    Sub state: ' + status.substate + '\n';
        out += '    Blocks sent: ' + status.blocks_sent + '\n';
        out += '    Bytes sent: ' + status.bytes_sent;
        logger.error(out);
        this.state.eventBeanError(status.substate);
      } else {
        this.state.eventBeanState(status.state);
      }
    }
  }, {
    key: 'start',
    value: function start() {
      var _this2 = this;

      logger.info('Beginning sketch upload of sketch: ' + this._sketchName);
      var serialTransport = this._device.getSerialTransportService();
      serialTransport.registerForCommandNotification(commandIds.BL_STATUS, function (statusCommand) {
        return _this2._statusCommandReceived(statusCommand);
      });
      this.setState(STATE_AWAIT_READY);
    }
  }, {
    key: 'shouldPromptUser',
    value: function shouldPromptUser() {
      return this._promptUser;
    }
  }, {
    key: 'getDevice',
    value: function getDevice() {
      return this._device;
    }
  }, {
    key: 'getSketchBuffer',
    value: function getSketchBuffer() {
      return this._sketchBuf;
    }
  }, {
    key: 'getSketchName',
    value: function getSketchName() {
      return this._sketchName;
    }
  }, {
    key: 'complete',
    value: function complete(error) {
      this._callback(error);
    }
  }]);

  return UploadProcess;
}(fsm.Context);

var SketchUploadState = function (_fsm$State) {
  _inherits(SketchUploadState, _fsm$State);

  function SketchUploadState() {
    _classCallCheck(this, SketchUploadState);

    return _possibleConstructorReturn(this, (SketchUploadState.__proto__ || Object.getPrototypeOf(SketchUploadState)).apply(this, arguments));
  }

  _createClass(SketchUploadState, [{
    key: 'enterState',


    // Override any methods in subclasses
    value: function enterState(previousState) {}
  }, {
    key: 'exitState',
    value: function exitState() {}
  }, {
    key: 'eventBeanState',
    value: function eventBeanState(state) {}
  }, {
    key: 'eventBeanError',
    value: function eventBeanError(substate) {}
  }]);

  return SketchUploadState;
}(fsm.State);

var StateInactive = function (_SketchUploadState) {
  _inherits(StateInactive, _SketchUploadState);

  function StateInactive() {
    _classCallCheck(this, StateInactive);

    return _possibleConstructorReturn(this, (StateInactive.__proto__ || Object.getPrototypeOf(StateInactive)).apply(this, arguments));
  }

  _createClass(StateInactive, [{
    key: 'enterState',
    value: function enterState(previousState) {
      if (previousState) {
        if (previousState === STATE_COMPLETED) {
          // Sketch completed successfully
          logger.info('Sketch completed successfully!');
          this.ctx.complete(null);
        } else {
          // Sketch upload error
          logger.error('Sketch upload error!');
          this.ctx.complete('Sketch upload failed');
        }
      }
    }
  }]);

  return StateInactive;
}(SketchUploadState);

var StateAwaitReady = function (_SketchUploadState2) {
  _inherits(StateAwaitReady, _SketchUploadState2);

  function StateAwaitReady() {
    _classCallCheck(this, StateAwaitReady);

    return _possibleConstructorReturn(this, (StateAwaitReady.__proto__ || Object.getPrototypeOf(StateAwaitReady)).apply(this, arguments));
  }

  _createClass(StateAwaitReady, [{
    key: 'enterState',
    value: function enterState(previousState) {
      var serialTransport = this.ctx.getDevice().getSerialTransportService();
      var sketchBuf = this.ctx.getSketchBuffer();
      var sketchName = this.ctx.getSketchName();

      var cmdArgs = [sketchBuf.length, // hex size
      util.crc16(sketchBuf), // hex crc
      new Date().getTime() / 1000, // unix timestamp
      sketchName.length, // sketch name size
      sketchName // sketch name
      ];

      if (this.ctx.shouldPromptUser()) {
        util.userInput.question('Press ENTER to begin upload:\n', function () {
          logger.info('Sketch upload started!');
          serialTransport.sendCommand(commandIds.BL_CMD_START, cmdArgs);
        });
      } else {
        logger.info('Sketch upload started!');
        serialTransport.sendCommand(commandIds.BL_CMD_START, cmdArgs);
      }
    }
  }, {
    key: 'eventBeanState',
    value: function eventBeanState(state) {
      if (state == BEAN_STATE_READY) {
        this.ctx.setState(STATE_BLOCK_TRANSFER);
      } else {
        logger.error('Unexpected Bean sketch state: ' + state);
        this.ctx.setState(STATE_INACTIVE);
      }
    }
  }]);

  return StateAwaitReady;
}(SketchUploadState);

var StateBlockTransfer = function (_SketchUploadState3) {
  _inherits(StateBlockTransfer, _SketchUploadState3);

  function StateBlockTransfer() {
    _classCallCheck(this, StateBlockTransfer);

    return _possibleConstructorReturn(this, (StateBlockTransfer.__proto__ || Object.getPrototypeOf(StateBlockTransfer)).apply(this, arguments));
  }

  _createClass(StateBlockTransfer, [{
    key: '_sendBlock',
    value: function _sendBlock() {
      logger.info('Sending Bean sketch block: ' + this._blocksSent + '/' + (this._totalBlocks - 1));
      var blockStart = this._blocksSent * BLOCK_SIZE;
      var blockEnd = blockStart + BLOCK_SIZE;
      if (blockEnd > this._sketchBuffer.length) {
        blockEnd = this._sketchBuffer.length;
      }
      var blockBuffer = this._sketchBuffer.slice(blockStart, blockEnd);
      this._serialTransport.sendCommand(commandIds.BL_FW_BLOCK, [blockBuffer]);
      if (blockEnd == this._sketchBuffer.length) {
        clearInterval(this._blockTimer);
      } else {
        this._blocksSent++;
      }
    }
  }, {
    key: 'enterState',
    value: function enterState(previousState) {
      var _this7 = this;

      this._serialTransport = this.ctx.getDevice().getSerialTransportService();
      this._sketchBuffer = this.ctx.getSketchBuffer();
      this._totalBlocks = Math.ceil(this._sketchBuffer.length / BLOCK_SIZE);
      this._blocksSent = 0;
      this._blockTimer = timers.setInterval(function () {
        _this7._sendBlock();
      }, 200);
    }
  }, {
    key: 'eventBeanState',
    value: function eventBeanState(state) {
      if (state === BEAN_STATE_COMPLETE) {
        this.ctx.setState(STATE_COMPLETED);
        return;
      }

      if (state !== BEAN_STATE_PROGRAMMING) {
        logger.error('Unexpected Bean sketch state: ' + state);
        this.ctx.setState(STATE_INACTIVE);
      }
    }
  }, {
    key: 'eventBeanError',
    value: function eventBeanError(substate) {
      clearInterval(this._blockTimer);
      this.ctx.setState(STATE_INACTIVE);
    }
  }]);

  return StateBlockTransfer;
}(SketchUploadState);

var StateCompleted = function (_SketchUploadState4) {
  _inherits(StateCompleted, _SketchUploadState4);

  function StateCompleted() {
    _classCallCheck(this, StateCompleted);

    return _possibleConstructorReturn(this, (StateCompleted.__proto__ || Object.getPrototypeOf(StateCompleted)).apply(this, arguments));
  }

  _createClass(StateCompleted, [{
    key: 'enterState',
    value: function enterState(previousState) {
      logger.info('Sketch upload complete!');
      this.ctx.setState(STATE_INACTIVE);
    }
  }]);

  return StateCompleted;
}(SketchUploadState);

module.exports = {
  SketchUploader: SketchUploader
};