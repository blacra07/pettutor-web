'use strict';

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var buffer = require('buffer');

var INTEL_HEX_DATA = 0;
var INTEL_HEX_END_OF_FILE = 1;
var INTEL_HEX_EXTENDED_SEGMENT_ADDRESS = 2;
var INTEL_HEX_START_SEGMENT_ADDRESS = 3;
var INTEL_HEX_EXTENDED_LINEAR_ADDRESS = 4;
var INTEL_HEX_START_LINEAR_ADDRESS = 5;

/**
 * Extract the "data" from an Intel hex line
 *
 * An Intel hex line looks like this
 *
 * :100000005CC000000C9450080C947D087EC0000079
 *
 * Once the ':' character is removed, each set of two characters represent a
 * Hexadecimal octet, or byte. However, not every byte in the string is considered
 * data, here is what the bytes mean:
 *
 *     Byte(s) [  0]    = Byte count
 *     Byte(s) [1:2]    = Address
 *     Byte(s) [  3]    = Record type
 *     Byte(s) [  n]    = Data
 *     Byte(s) [n+1]    = Checksum
 *
 * @param intelHexLine Ascii Intel hex line
 * @returns
 */
function extractDataFromIntelHexLine(intelHexLine) {
  if (!intelHexLine.startsWith(':')) {
    throw new Error('Intel hex lines need to start with \':\'');
  }

  var asciiHex = intelHexLine.slice(1, intelHexLine.length);

  if (asciiHex.length === 0) {
    throw new Error('Length of ascii hex string needs to be greater than 0');
  }

  if (asciiHex.length % 2 !== 0) {
    throw new Error('Length of ascii hex string needs to be even');
  }

  var rawBytes = [];

  for (var i = 0; i < asciiHex.length; i += 2) {
    var asciiByte = asciiHex.slice(i, i + 2);
    rawBytes.push(parseInt(asciiByte, 16));
  }

  if (rawBytes[3] === INTEL_HEX_DATA) {
    var dataBytes = rawBytes.slice(4, rawBytes.length - 1);
    var bytes = new buffer.Buffer(dataBytes.length);
    for (var _i = 0; _i < dataBytes.length; _i++) {
      bytes.writeUInt8(dataBytes[_i], _i);
    }
    return bytes;
  } else {
    return null;
  }
}

/**
 * Encapsulation of an Intel hex file which provides a method to extract data
 */

var IntelHexFile = function () {
  function IntelHexFile(ascii) {
    _classCallCheck(this, IntelHexFile);

    this._ascii = ascii;
  }

  /**
   * Parse the raw ascii data from an Intel hex file
   *
   * This method will check for errors and return the binary data.
   *
   */


  _createClass(IntelHexFile, [{
    key: 'parse',
    value: function parse() {
      var dataBuffers = [];
      var lines = this._ascii.split('\r\n');

      if (lines[lines.length - 1] !== '') {
        throw new Error('Intel hex files should end with a newline');
      }

      var _iteratorNormalCompletion = true;
      var _didIteratorError = false;
      var _iteratorError = undefined;

      try {
        for (var _iterator = lines.slice(0, lines.length - 1)[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
          var l = _step.value;

          var data = extractDataFromIntelHexLine(l);
          if (data !== null) {
            dataBuffers.push(data);
          }
        }
      } catch (err) {
        _didIteratorError = true;
        _iteratorError = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion && _iterator.return) {
            _iterator.return();
          }
        } finally {
          if (_didIteratorError) {
            throw _iteratorError;
          }
        }
      }

      var totalByteLength = 0;
      var _iteratorNormalCompletion2 = true;
      var _didIteratorError2 = false;
      var _iteratorError2 = undefined;

      try {
        for (var _iterator2 = dataBuffers[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
          var b = _step2.value;

          totalByteLength += b.length;
        }
      } catch (err) {
        _didIteratorError2 = true;
        _iteratorError2 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion2 && _iterator2.return) {
            _iterator2.return();
          }
        } finally {
          if (_didIteratorError2) {
            throw _iteratorError2;
          }
        }
      }

      return buffer.Buffer.concat(dataBuffers, totalByteLength);
    }
  }]);

  return IntelHexFile;
}();

module.exports = {
  IntelHexFile: IntelHexFile
};