'use strict';

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var BleServices = require('./services/services');
var fs = require('fs');
var path = require('path');
var buffer = require('buffer');
var logger = require('./util/logs').logger;

var BLOCK_LENGTH = 16;
var FW_HEADER_LENGTH = 12;
var MAX_BLOCKS_IN_AIR = 8;
var DEBUG = false;

// OAD state machine
// - These are states related the "global" OAD state
var OAD_STATE_IN_PROGRESS = 'OAD_STATE_IN_PROGRESS';
var OAD_STATE_NOT_IN_PROGRESS = 'OAD_STATE_NOT_IN_PROGRESS';

// OAD step state machine
// - These are states related to a given "step" of the OAD update process.
//   A new step begins when the Bean power-cycles.
var OAD_STEP_STATE_CHECKING_FW = 'OAD_STEP_STATE_CHECKING_FW';
var OAD_STEP_STATE_OFFERING_FILES = 'OAD_STEP_STATE_OFFERING_FILES';
var OAD_STEP_STATE_BLOCK_XFER = 'OAD_STEP_STATE_BLOCK_XFER';
var OAD_STEP_STATE_REBOOTING = 'OAD_STEP_STATE_REBOOTING';

var FirmwareUpdater = function () {
  function FirmwareUpdater(lb) {
    _classCallCheck(this, FirmwareUpdater);

    this._lb = lb;
    this._fwfiles = [];
    this._storedFwVersion = null;

    this.resetState(true);
  }

  _createClass(FirmwareUpdater, [{
    key: 'resetState',
    value: function resetState() {
      var init = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;

      /**
       * Reset or instantiate all FW state
       * TODO: This state is for ONE device, eventually this class should be
       *       capable of updating many devices simultaneously
       */

      this._deviceInProgress = null;
      this._completionCallback = null;
      this._fileOfferedIndex = -1;
      this._currentFwFile = null;
      this._lastBlock = 0;
      this._totalBlocks = null;
      this._fwBeginTime = null;
      this._step = null;
      this._stateGlobal = OAD_STATE_NOT_IN_PROGRESS;
      this._stateStep = null;
      this._nextBlock = 0;
      this._blockTransferStartTime = null;
      this._force = false;

      if (!init) {
        // We don't want to log anything from the constructor
        logger.info("OAD State Machine reset!");
      }
    }
  }, {
    key: '_fail',
    value: function _fail(err) {
      /**
       * Helper function: call when an error occurs
       */

      logger.info(err);
      this._completionCallback(err);
      fs.closeSync(this._currentFwFile);
      this.resetState();
    }
  }, {
    key: '_registerNotifications',
    value: function _registerNotifications(device) {
      var _this = this;

      /**
       * Register for notifications on *Block* and *Identify* characteristics
       */

      var oad = device.getOADService();
      oad.registerForNotifications(BleServices.oad.characteristics.IDENTIFY, function (data) {
        _this._notificationIdentify(data);
      });
      oad.registerForNotifications(BleServices.oad.characteristics.BLOCK, function (data) {
        _this._notificationBlock(data);
      });
    }
  }, {
    key: '_notificationBlock',
    value: function _notificationBlock(buf) {
      /**
       * Callback: received a notification on Block characteristic
       *
       * A notification to this characteristic means the Bean has accepted the most recent
       * firmware file we have offered, which is stored as `this._currentFwFile`. It is now
       * time to start sending blocks of FW to the device.
       *
       * @param buf 2 byte Buffer containing the block number
       */

      var blkNoRequested = buf.readUInt16LE(0, 2);

      if (blkNoRequested === 0) {
        var filename = path.parse(this._fwfiles[this._fileOfferedIndex]).name;
        logger.info('ACCEPTED IMAGE: ' + filename);
        logger.info('Got request for the first BLOCK of FW');
        this._stateStep = OAD_STEP_STATE_BLOCK_XFER;

        // calculate size of image to get total blocks
        var fwFileStats = fs.statSync(this._fwfiles[this._fileOfferedIndex]);
        this._totalBlocks = fwFileStats.size / BLOCK_LENGTH - 1;
        logger.info('Total blocks: ' + this._totalBlocks);
        logger.info('FW file size: ' + fwFileStats.size);
        this._step += 1;
        logger.info('Starting step #' + this._step + '!');
        this._lb.stopScanning();
        this._blockTransferStartTime = Math.round(+new Date() / 1000);
      }

      if (blkNoRequested % 512 === 0) logger.info('Got request for FW block ' + blkNoRequested);

      if (DEBUG) logger.info(Math.round(+new Date()) + ' - REQUESTED: ' + blkNoRequested);

      while (this._stateStep == OAD_STEP_STATE_BLOCK_XFER && this._nextBlock <= this._totalBlocks && this._nextBlock < blkNoRequested + MAX_BLOCKS_IN_AIR) {

        // read block from open file
        var fileOffset = this._nextBlock * BLOCK_LENGTH;
        var blkBuf = new buffer.Buffer(BLOCK_LENGTH);
        var bytesRead = fs.readSync(this._currentFwFile, blkBuf, 0, BLOCK_LENGTH, fileOffset);
        if (bytesRead != BLOCK_LENGTH) {
          return this._fail('Internal error: failed to read FW file...');
        }

        var blockAddr = new buffer.Buffer(2);
        blockAddr[0] = this._nextBlock & 0xFF;
        blockAddr[1] = this._nextBlock >> 8 & 0xFF;
        var finalBuf = buffer.Buffer.concat([blockAddr, blkBuf]);
        this._deviceInProgress.getOADService().writeToBlock(finalBuf, function (err) {
          if (err) logger.info('Error writing to block char: ' + err);
        });

        if (DEBUG) logger.info(Math.round(+new Date()) + ' - SENT: ' + this._nextBlock);

        this._nextBlock += 1;
      }

      if (this._nextBlock > this._totalBlocks) {
        logger.info('Last block Sent');
        var blockEndTime = Math.round(+new Date() / 1000);
        logger.info('Sent ' + this._totalBlocks + ' in ' + (blockEndTime - this._blockTransferStartTime) + ' seconds');
        this._nextBlock = 0; // Reset Back to 0 for new file or done FWU!
        this._fileOfferedIndex = -1; // reset fileOfferedIndex

        this._lb.startScanning();
        this._stateStep = OAD_STEP_STATE_REBOOTING;
        logger.info('Waiting for device to reset: ' + this._deviceInProgress.toString());
      }
    }
  }, {
    key: '_notificationIdentify',
    value: function _notificationIdentify(buf) {
      /**
       * Callback: received a notification on Identify characteristic
       *
       * Any notification to this characteristic means we should offer the next firmware file
       * in the list. If it accepts, the next notification will be on the Block char.
       *
       * @param buf Unused
       */

      if (this._fileOfferedIndex != -1) {
        var _filepath = this._fwfiles[this._fileOfferedIndex];
        var _filename = path.parse(_filepath).name;
        logger.info('REJECTED IMAGE: %s', _filename);
      }

      this._stateStep = OAD_STEP_STATE_OFFERING_FILES;

      this._fileOfferedIndex++;

      if (this._fileOfferedIndex >= this._fwfiles.length) {
        this._fail("All firmware images have been rejected");
      }

      var filepath = this._fwfiles[this._fileOfferedIndex];
      var filename = path.parse(filepath).name;

      var hdrBuf = new buffer.Buffer(FW_HEADER_LENGTH);

      // Read bytes 4-16 from the file (12 bytes total)
      this._currentFwFile = fs.openSync(filepath, 'r');
      var bytesRead = fs.readSync(this._currentFwFile, hdrBuf, 0, FW_HEADER_LENGTH, 4);
      if (bytesRead != FW_HEADER_LENGTH) {
        return this._fail('Internal error: failed to read FW file');
      }

      logger.info('Offering image: ' + filename);

      this._deviceInProgress.getOADService().writeToIdentify(hdrBuf, function (err) {
        if (err) logger.info('Error writing to identify char: ' + err);
      });
    }
  }, {
    key: '_checkFirmwareVersion',
    value: function _checkFirmwareVersion(device, callback) {
      var _this2 = this;

      /**
       * Check that the device needs a FW update by checking it's FW version
       *
       * @param device A LightBlue device object
       * @param callback A callback function that takes one param, an error
       */

      var dis = device.getDeviceInformationService();
      dis.resetCache();
      this._stateStep = OAD_STEP_STATE_CHECKING_FW;
      dis.getFirmwareVersion(function (err, fwVersion) {
        if (err) {
          callback(err);
        } else {
          var v = fwVersion.toString('utf8').split(' ')[0];
          logger.info('Comparing firmware versions: Bundle version (' + _this2._storedFwVersion + '), Bean version (' + v + ')');

          if (_this2._storedFwVersion === v) {
            if (_this2._force && _this2._stateGlobal === OAD_STATE_NOT_IN_PROGRESS) {
              logger.info('Versions are the same, but updating anyway');
              callback(null);
            } else {
              callback('Versions are the same, no update needed');
            }
          } else {
            callback(null);
          }
        }
      });
    }
  }, {
    key: 'failedToReconnect',
    value: function failedToReconnect() {
      this._fail("Failed to reconnect to device!");
    }
  }, {
    key: 'getState',
    value: function getState() {
      return {
        accepted_fw_file: this._fwfiles[this._fileOfferedIndex],
        last_block: this._lastBlock,
        total_blocks: this._totalBlocks,
        step: this._step
      };
    }
  }, {
    key: 'isInProgress',
    value: function isInProgress(device) {
      /**
       * Determine if `device` is in the middle of a FW update procedure
       *
       * @param device a LB Device object
       */

      logger.info('Checking if device is in progress...');

      if (this._deviceInProgress === null) {
        logger.info('No device is in progress!');
        return false;
      }

      logger.info('Current device in progress: ' + this._deviceInProgress.toString());
      logger.info('Questionable device: ' + device.toString());
      return device.getAddress() === this._deviceInProgress.getAddress();
    }
  }, {
    key: 'continueUpdate',
    value: function continueUpdate() {
      var _this3 = this;

      /**
       * Continue an update procedure for `device` assuming it passes FW version check
       */

      logger.info('Continue update called');

      this._checkFirmwareVersion(this._deviceInProgress, function (err) {
        if (err) {
          if (_this3._completionCallback) {
            logger.info('' + err);
            logger.info('FW update COMPLETED for ' + _this3._deviceInProgress.toString());
            var end = Math.round(+new Date() / 1000);
            var sum = end - _this3._fwBeginTime;
            logger.info('FW update process took ' + sum + ' seconds');
            _this3._completionCallback(null, err); // This should mean we are done!!
            _this3.resetState();
          } else {
            logger.info('FW Version Error: ' + err);
          }
        } else {
          logger.info('Continuing FW update for device ' + _this3._deviceInProgress.toString());
          _this3._registerNotifications(_this3._deviceInProgress);
          _this3._deviceInProgress.getOADService().triggerIdentifyHeaderNotification();
        }
      });
    }
  }, {
    key: 'beginUpdate',
    value: function beginUpdate(device, bundle, force, callback) {
      var _this4 = this;

      /**
       * Begin an update procedure for `device` assuming it passes FW version check
       *
       * @param device A LightBlue device object
       * @param callback A callback function that takes one param, an error
       */

      logger.info('Begin update called');
      this._fwfiles = bundle;
      this._force = force;
      var filename = path.parse(this._fwfiles[0]).name;
      this._storedFwVersion = filename.split('_')[0];

      this._checkFirmwareVersion(device, function (err) {
        if (err) {
          logger.info('FW Version Error: ' + err);
          callback(err);
        } else {
          logger.info('Starting FW update for device ' + device.toString());
          _this4._stateGlobal = OAD_STATE_IN_PROGRESS;
          _this4._deviceInProgress = device;
          _this4._completionCallback = callback;
          _this4._registerNotifications(device);
          _this4._fwBeginTime = Math.round(+new Date() / 1000);
          logger.info('Begin FW @ ' + _this4._fwBeginTime);
          device.getOADService().triggerIdentifyHeaderNotification();
        }
      });
    }
  }]);

  return FirmwareUpdater;
}();

module.exports = {
  FirmwareUpdater: FirmwareUpdater
};