'use strict';

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var devices = require('./devices');
var FirmwareUpdater = require('./firmware-updater').FirmwareUpdater;
var SketchUploader = require('./sketch-uploader').SketchUploader;
var events = require('events');
var logger = require('./util/logs').logger;
var async = require('async');

var NOBLE_STATE_READY = 'poweredOn';

var LightBlueSDK = function (_events$EventEmitter) {
  _inherits(LightBlueSDK, _events$EventEmitter);

  /**
   * Core LightBlue SDK class
   *
   * This class implements the EventEmitter which allows clients to register
   * for events using the .on() method. Events include:
   *
   *    - "discover"
   *
   */

  function LightBlueSDK() {
    _classCallCheck(this, LightBlueSDK);

    // Dependencies
    var _this = _possibleConstructorReturn(this, (LightBlueSDK.__proto__ || Object.getPrototypeOf(LightBlueSDK)).call(this));

    _this._noble = require('noble');
    _this._fwUpdater = new FirmwareUpdater(_this);
    _this._sketchUploader = new SketchUploader();

    // State
    _this._devices = {};
    _this._scannedDevices = {};
    _this._scanning = false;
    _this._scanTimeout = null;
    _this._filter = false; // filter on lightblue devices only

    _this._noble.on('discover', function (peripheral) {
      _this._discover(peripheral);
    });
    return _this;
  }

  _createClass(LightBlueSDK, [{
    key: '_discover',
    value: function _discover(peripheral) {
      /**
       * A new BLE peripheral device has been discovered (from Noble)
       */

      var address = peripheral.uuid;
      var scannedDevice = this._scannedDevices[address];
      if (!scannedDevice) {
        scannedDevice = new devices.ScannedDevice(peripheral);
        this._scannedDevices[address] = scannedDevice;
      }

      var updated = scannedDevice.update(peripheral);

      if (this._checkForUpdateInProgress(scannedDevice)) {
        return; // Don't emit any events during fw update for this device
      }

      if (scannedDevice.getType() === devices.DEVICE_TYPE_LIGHT_BLUE && updated || this._filter === false && updated) {
        this.emit('discover', scannedDevice);
      }
    }
  }, {
    key: '_checkForUpdateInProgress',
    value: function _checkForUpdateInProgress(scannedDevice) {
      var _this2 = this;

      var updateInProgress = false;
      var device = this._devices[scannedDevice.getAddress()];
      if (device) {
        device.update(scannedDevice.getPeripheral());
        if (this._fwUpdater.isInProgress(device)) {
          updateInProgress = true;
          if (!device.isConnectedOrConnecting()) {
            device.connect(function (err, device) {
              device.lookupServices(function (err) {
                _this2._fwUpdater.continueUpdate();
              });
            });
          }
        }
      }
      return updateInProgress;
    }
  }, {
    key: 'quitGracefully',
    value: function quitGracefully(callback) {
      var _this3 = this;

      var disconnects = [];

      this.stopScanning();

      Object.keys(this._devices).forEach(function (key) {
        var d = _this3._devices[key];
        disconnects.push(function (disconnectCallback) {
          d.disconnect(disconnectCallback);
        });
      });

      async.parallel(disconnects, function (error, results) {
        logger.info('All devices have disconnected');
        callback(error);
      });
    }
  }, {
    key: 'reset',
    value: function reset() {
      logger.info('Disconnected all devices!');
      this._disconnectDevices();
      logger.info('Clearing device cache!');
      this._devices = {};
      this._fwUpdater.resetState();
    }
  }, {
    key: 'startScanning',
    value: function startScanning() {
      var timeoutSeconds = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 30;
      var filter = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
      var timeoutCallback = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;

      /**
       * Start a BLE scan for a given period of time
       *
       * @param timeout int Number of seconds to scan
       * @param timeoutCallback Function called back after scan timeout
       */

      var _ctx = this;
      var _noble = this._noble;
      this._filter = filter;

      if (_noble.state === NOBLE_STATE_READY) {
        logger.info('Starting to scan...');
        _noble.startScanning([], true);
        this._scanning = true;
      } else {
        _noble.on('stateChange', function (state) {
          if (state === NOBLE_STATE_READY) {
            logger.info('Starting to scan...');
            _noble.startScanning([], true);
            _ctx._scanning = true;
          }
        });
      }

      logger.info('Setting scan timeout: ' + timeoutSeconds + ' seconds');
      this._scanTimeout = setTimeout(function () {
        logger.info("Scan timeout!");
        _ctx.stopScanning();
        if (timeoutCallback) {
          timeoutCallback();
        }
      }, timeoutSeconds * 1000);
    }
  }, {
    key: 'stopScanning',
    value: function stopScanning() {
      logger.info('No longer scanning...');
      clearTimeout(this._scanTimeout);
      this._noble.stopScanning();
      this._scanning = false;
    }
  }, {
    key: 'getDeviceForUUID',
    value: function getDeviceForUUID(uuid) {
      return this._devices[uuid];
    }

    /**
     * Update a devices firmware
     *
     * @param device LightBlue Device object
     * @param bundle an array of firmware images
     */

  }, {
    key: 'updateFirmware',
    value: function updateFirmware(device, bundle, force, callback) {
      this._fwUpdater.beginUpdate(device, bundle, force, callback);
    }
  }, {
    key: 'uploadSketch',
    value: function uploadSketch(device, sketchBuf, sketchName, promptUser, callback) {
      this.stopScanning();
      this._sketchUploader.beginUpload(device, sketchBuf, sketchName, promptUser, callback);
    }
  }, {
    key: 'connectScannedDevice',
    value: function connectScannedDevice(scannedDevice, callback) {
      var device = this._devices[scannedDevice.getAddress()];
      if (device) {
        device.update(scannedDevice.getPeripheral());
      } else {
        if (scannedDevice.getType() === devices.DEVICE_TYPE_LIGHT_BLUE) {
          device = new devices.LightBlueDevice(scannedDevice.getPeripheral());
        } else {
          device = new devices.BleDevice(scannedDevice.getPeripheral());
        }
        this._devices[device.getAddress()] = device;
      }

      device.connect(callback);
    }
  }]);

  return LightBlueSDK;
}(events.EventEmitter);

var sdk = null;

function getSdk() {
  if (!sdk) {
    sdk = new LightBlueSDK();
  }

  return sdk;
}

module.exports = {
  sdk: getSdk
};