'use strict';

var intelhex = require('../../util/intelhex');
var common = require('./common');
var fs = require('fs-extra');
var path = require('path');
var paths = require('../../util/paths');
var platform = require("../../util/platform");
var util = require('../../util/util');

var FIRMWARE_BUNDLES = paths.getResource('firmware_bundles');

function lookupFirmwareBundleForHardwareVersion(hardwareVersion) {
  var bundleDir = void 0;
  if (hardwareVersion.startsWith('1') || hardwareVersion.startsWith('E')) {
    bundleDir = path.join(FIRMWARE_BUNDLES, 'bean');
  } else if (hardwareVersion.startsWith('2')) {
    bundleDir = path.join(FIRMWARE_BUNDLES, 'beanplus');
  } else {
    throw new Error('Unrecognized hardware version: ' + hardwareVersion);
  }

  var bundle = [];
  var _iteratorNormalCompletion = true;
  var _didIteratorError = false;
  var _iteratorError = undefined;

  try {
    for (var _iterator = fs.readdirSync(bundleDir).sort()[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
      var filename = _step.value;

      // Sometimes there are hidden files we don't want to include (.DS_Store)
      if (!filename.startsWith('.')) bundle.push(path.join(bundleDir, filename));
    }
  } catch (err) {
    _didIteratorError = true;
    _iteratorError = err;
  } finally {
    try {
      if (!_iteratorNormalCompletion && _iterator.return) {
        _iterator.return();
      }
    } finally {
      if (_didIteratorError) {
        throw _iteratorError;
      }
    }
  }

  return bundle;
}

function programFirmware(sdk, beanName, beanUUID, force, completedCallback) {

  common.connectToDevice(sdk, beanName, beanUUID, function (device) {

    device.getDeviceInformationService().getHardwareVersion(function (err, version) {
      if (err) {
        completedCallback(err);
      } else {

        var bundle = lookupFirmwareBundleForHardwareVersion(version.toString('utf8'));

        console.log('Programming device firmware: ' + device.getAddress());

        sdk.updateFirmware(device, bundle, force, function (err) {

          if (err) {
            completedCallback('FW update failed: ' + err);
          } else {
            completedCallback(null);
          }
        });
      }
    });
  }, completedCallback);
}

function _uploadSketch(sdk, device, sketchData, sketchName, oops, callback) {

  sdk.uploadSketch(device, sketchData, sketchName, oops === true, function (err) {
    if (err) {
      callback('Sketch upload failed: ' + err);
    } else {
      callback(null);
    }
  });
}

function _getSketchData(device, sketch, callback) {

  device.getDeviceInformationService().getHardwareVersion(function (err, version) {
    if (err) callback(err);

    var hexPath = void 0;
    var sketchName = void 0;
    if (sketch.endsWith('.hex')) {
      hexPath = sketch;
      if (!fs.existsSync(hexPath)) {
        callback('Invalid hex file path: ' + hexPath);
        return;
      }

      sketchName = path.parse(hexPath).name;
      console.log('Found sketch at path: ' + hexPath);
    } else {

      sketchName = sketch;
      var hexFile = sketch + '.hex';
      var hardwareVersion = version.toString('utf8');

      var sketchDir = void 0;
      var boardName = void 0;
      if (hardwareVersion.startsWith('1') || hardwareVersion.startsWith('E')) {
        sketchDir = common.SKETCH_LOCATION_BEAN;
        boardName = 'Bean';
      } else if (hardwareVersion.startsWith('2')) {
        sketchDir = common.SKETCH_LOCATION_BEANPLUS;
        boardName = 'Bean+';
      } else {
        callback('Unrecognized hardware version: ' + hardwareVersion);
        return;
      }

      hexPath = path.join(sketchDir, hexFile);
      if (fs.existsSync(hexPath)) {
        console.log('Found sketch ' + sketch + ' for board ' + boardName);
      } else {
        callback('No sketch with name "' + sketch + '" for board ' + boardName);
        return;
      }
    }

    var asciiData = fs.readFileSync(hexPath, 'ascii');
    var intelHex = new intelhex.IntelHexFile(asciiData);
    var binarySketchData = intelHex.parse();
    callback(null, binarySketchData, sketchName);
  });
}

function programSketch(sdk, sketch, beanName, beanUUID, oops, completedCallback) {

  common.connectToDevice(sdk, beanName, beanUUID, function (device) {
    _getSketchData(device, sketch, function (error, binary, sketchName) {
      if (error) {
        completedCallback(error);
      } else {
        _uploadSketch(sdk, device, binary, sketchName, oops, completedCallback);
      }
    });
  }, completedCallback);
}

function listCompiledSketches(clean, completedCallback) {

  console.log('');

  var beanSketches = fs.readdirSync(common.SKETCH_LOCATION_BEAN);
  console.log('Bean Sketches:');
  if (beanSketches.length < 1) {
    console.log('    None.');
  } else {
    for (var i in beanSketches) {
      var f = beanSketches[i];
      console.log('    ' + i + ': ' + f.split('.')[0]);
    }
  }

  console.log('');

  var beanPlusSketches = fs.readdirSync(common.SKETCH_LOCATION_BEANPLUS);
  console.log('Bean+ Sketches:');
  if (beanPlusSketches.length < 1) {
    console.log('    None.');
  } else {
    for (var _i in beanPlusSketches) {
      var _f = beanPlusSketches[_i];
      console.log('    ' + _i + ': ' + _f.split('.')[0]);
    }
  }

  if (clean === true) {
    util.userInput.question('Are you sure you want to delete compiled sketches? (y/n):', function (input) {
      input.replace('\r\n', '');
      if (input.toLowerCase() === 'y') {
        common.cleanSketchFolder();
        console.log('Sketches have been deleted.');
      } else if (input.toLowerCase() !== 'y' || input.toLowerCase() !== 'n') {
        console.log('Sketches have NOT been deleted.');
      }
      completedCallback(null);
    });
  } else {
    completedCallback(null);
  }
}

module.exports = {
  programFirmware: programFirmware,
  programSketch: programSketch,
  listCompiledSketches: listCompiledSketches
};