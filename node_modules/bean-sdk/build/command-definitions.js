'use strict';

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var binary = require('./util/binary');
var util = require('./util/util');
var buffer = require('buffer');
var yaml = require('js-yaml');
var fs = require('fs');
var path = require('path');
var logger = require('./util/logs').logger;

var DEFINITIONS_FILE = path.join(__dirname, 'resources', 'command-definitions.yaml');
var MESSAGE_RESPONSE_BIT = 0x80;

var _defns = null;

function _loadDefinitions() {
  try {
    var commandDefs = yaml.safeLoad(fs.readFileSync(DEFINITIONS_FILE, 'utf8'));
    _defns = commandDefs;
  } catch (e) {
    logger.info('Failed to load definitions: ' + e);
  }
}

function _binaryField(type) {

  var binaryField = null;

  switch (type) {
    case 'uint8':
      binaryField = binary.UInt8;
      break;
    case 'uint16':
      binaryField = binary.UInt16;
      break;
    case 'uint32':
      binaryField = binary.UInt32;
      break;
    case 'int16':
      binaryField = binary.Int16;
      break;
    case 'padded_string':
      binaryField = binary.PaddedString;
      break;
    case 'fixed_length_bytes':
      binaryField = binary.FixedLengthBytes;
      break;
    case 'variable_length_bytes':
      binaryField = binary.VariableLengthBytes;
      break;
    default:
      logger.info('No binary type found: ' + type);
  }

  return binaryField;
}

var Message = function () {

  /**
   * Represents a LightBlue Serial Transport Message
   *
   * Defined as:
   *
   *    [1 byte]         - Length     (Message ID + Payload)
   *    [1 byte]         - Reserved
   *    [2 byte]      BE - Message ID
   *    [0-64 bytes]  LE - Payload
   *    [2 bytes]     LE - CRC        (Everything before CRC)
   *
   * @param messageId
   * @param definition
   */

  function Message(messageId, args, definition) {
    _classCallCheck(this, Message);

    this._msgId = messageId;
    this._args = args;
    this._definition = definition;
  }

  _createClass(Message, [{
    key: '_packLength',
    value: function _packLength(payloadLength) {
      var buf = new buffer.Buffer(1);
      buf.writeUInt8(payloadLength + 2, 0); // Length = payload + msg ID
      return buf;
    }
  }, {
    key: '_packReserved',
    value: function _packReserved() {
      var buf = new buffer.Buffer(1);
      buf.writeUInt8(0, 0);
      return buf;
    }
  }, {
    key: '_packMessageId',
    value: function _packMessageId() {
      var buf = new buffer.Buffer(2);
      buf.writeUInt16BE(this._msgId);
      return buf;
    }
  }, {
    key: '_packPayload',
    value: function _packPayload(args) {
      var packedArgs = [];
      var totalLength = 0;
      for (var index in args) {
        var fieldDefinition = this._definition.arguments[index];
        var value = args[index];
        var Field = _binaryField(fieldDefinition.type);
        var binaryField = new Field(value, fieldDefinition);
        packedArgs.push(binaryField.pack());
        totalLength += binaryField.size();
      }
      return buffer.Buffer.concat(packedArgs, totalLength);
    }
  }, {
    key: '_packCRC',
    value: function _packCRC(crcBuf) {
      var crcValue = util.crc16(crcBuf);
      var buf = new buffer.Buffer(2);
      buf.writeUInt16LE(crcValue);
      return buf;
    }
  }, {
    key: 'getMessageId',
    value: function getMessageId() {
      return this._msgId;
    }
  }, {
    key: 'getArguments',
    value: function getArguments() {
      return this._args;
    }
  }, {
    key: 'getDefinition',
    value: function getDefinition() {
      return this._definition;
    }
  }, {
    key: 'pack',
    value: function pack() {
      throw new Error("Subclasses must implement method .pack()");
    }
  }, {
    key: 'asObject',
    value: function asObject(defn) {
      var obj = {};
      for (var idx in defn) {
        var fieldDefn = defn[idx];
        var fieldVal = this._args[idx];
        obj[fieldDefn.name] = fieldVal;
      }
      return obj;
    }
  }], [{
    key: '_unpackCRC',
    value: function _unpackCRC(buf) {
      var crcValue = buf.readUInt16LE(buf.length - 2);
      var crcBuf = buf.slice(0, buf.length - 2);
      var calcedCrc = util.crc16(crcBuf);
      if (crcValue != calcedCrc) {
        throw new Error('CRC Mismatch: ' + crcValue + ' != ' + calcedCrc);
      }
    }
  }, {
    key: '_unpackLength',
    value: function _unpackLength(buf) {
      return buf.readUInt8(0);
    }
  }, {
    key: '_unpackReserved',
    value: function _unpackReserved(buf) {
      return buf.readUInt8(1);
    }
  }, {
    key: '_unpackMessageId',
    value: function _unpackMessageId(buf) {
      var messageId = buf.readUInt16BE(2);
      return messageId & ~MESSAGE_RESPONSE_BIT;
    }
  }, {
    key: '_unpackPayload',
    value: function _unpackPayload(buf, payloadLength, argDefn) {
      var argsLength = payloadLength - 2; // Subtract message ID from length
      var payloadBuf = buf.slice(4, 4 + argsLength);
      var offset = 0;
      var argValues = [];
      var _iteratorNormalCompletion = true;
      var _didIteratorError = false;
      var _iteratorError = undefined;

      try {
        for (var _iterator = argDefn[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
          var fieldDefinition = _step.value;

          var Field = _binaryField(fieldDefinition.type);
          var binaryField = Field.fromBuffer(payloadBuf, offset, fieldDefinition);
          offset += binaryField.size();
          argValues.push(binaryField.getValue());
        }
      } catch (err) {
        _didIteratorError = true;
        _iteratorError = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion && _iterator.return) {
            _iterator.return();
          }
        } finally {
          if (_didIteratorError) {
            throw _iteratorError;
          }
        }
      }

      return argValues;
    }
  }, {
    key: 'fromBuffer',
    value: function fromBuffer(buf) {
      throw new Error("Subclasses must implement static method .fromBuffer(buf)");
    }
  }]);

  return Message;
}();

var Response = function (_Message) {
  _inherits(Response, _Message);

  function Response() {
    _classCallCheck(this, Response);

    return _possibleConstructorReturn(this, (Response.__proto__ || Object.getPrototypeOf(Response)).apply(this, arguments));
  }

  _createClass(Response, [{
    key: 'pack',
    value: function pack() {
      throw new Error("Not Implemented!");
    }
  }], [{
    key: 'fromBuffer',
    value: function fromBuffer(buf, defn) {
      var crc = this._unpackCRC(buf);
      var length = this._unpackLength(buf);
      var reserved = this._unpackReserved(buf);
      var messageId = this._unpackMessageId(buf);
      var payloadArgs = this._unpackPayload(buf, length, defn.response);
      return new Response(messageId, payloadArgs, defn);
    }
  }]);

  return Response;
}(Message);

var Command = function (_Message2) {
  _inherits(Command, _Message2);

  function Command() {
    _classCallCheck(this, Command);

    return _possibleConstructorReturn(this, (Command.__proto__ || Object.getPrototypeOf(Command)).apply(this, arguments));
  }

  _createClass(Command, [{
    key: 'pack',
    value: function pack() {
      var messageId = this._packMessageId();
      var payload = this._packPayload(this._args);
      var length = this._packLength(payload.length);
      var reserved = this._packReserved();
      var crc = this._packCRC(util.concatBuffers([length, reserved, messageId, payload]));
      return util.concatBuffers([length, reserved, messageId, payload, crc]);
    }
  }], [{
    key: 'fromBuffer',
    value: function fromBuffer(buf, defn) {
      var crc = this._unpackCRC(buf);
      var length = this._unpackLength(buf);
      var reserved = this._unpackReserved(buf);
      var messageId = this._unpackMessageId(buf);
      var payloadArgs = this._unpackPayload(buf, length, defn.arguments);
      return new Command(messageId, payloadArgs, defn);
    }
  }]);

  return Command;
}(Message);

function definitionForCommand(cmdId) {
  if (!_defns) {
    _loadDefinitions();
  }

  if (_defns.incoming[cmdId]) return _defns.incoming[cmdId];

  if (_defns.outgoing[cmdId]) return _defns.outgoing[cmdId];

  throw new Error('No definition for command ID: ' + cmdId);
}

function definitions() {
  if (!_defns) {
    _loadDefinitions();
  }

  return _defns;
}

var commandIds = {
  SERIAL_DATA: 0x0000,
  LB_PROTOCOL_ERROR: 0x0001,
  BT_SET_ADV: 0x0500,
  BT_SET_CONN: 0x0502,
  BT_SET_LOCAL_NAME: 0x0504,
  BT_SET_PIN: 0x0506,
  BT_SET_TX_PWR: 0x0508,
  BT_GET_CONFIG: 0x0510,
  BT_SET_CONFIG: 0x0511,
  BT_SET_CONFIG_NOSAVE: 0x0540,
  BT_END_GATE: 0x0550,
  BT_ADV_ONOFF: 0x0512,
  BT_SET_SCRATCH: 0x0514,
  BT_GET_SCRATCH: 0x0515,
  BT_RESTART: 0x0520,
  BL_CMD_START: 0x1000,
  BL_FW_BLOCK: 0x1001,
  BL_STATUS: 0x1002,
  BL_GET_META: 0x1003,
  CC_LED_WRITE: 0x2000,
  CC_LED_WRITE_ALL: 0x2001,
  CC_LED_READ_ALL: 0x2002,
  CC_ACCEL_READ: 0x2010,
  CC_TEMP_READ: 0x2011,
  CC_BATT_READ: 0x2015,
  CC_POWER_ARDUINO: 0x2020,
  CC_GET_AR_POWER: 0x2021,
  CC_ACCEL_GET_RANGE: 0x2030,
  CC_ACCEL_SET_RANGE: 0x2035,
  AR_SLEEP: 0x3000,
  ERROR_CC: 0x4000,
  DB_LOOPBACK: 0xFE00,
  DB_COUNTER: 0xFE01,
  DB_E2E_LOOPBACK: 0xFE02,
  DB_PTM: 0xFE03
};

module.exports = {
  commandIds: commandIds,
  definitionForCommand: definitionForCommand,
  definitions: definitions,
  Command: Command,
  Response: Response,
  MESSAGE_RESPONSE_BIT: MESSAGE_RESPONSE_BIT
};